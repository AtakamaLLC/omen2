from typing import TypeVar, Callable, Iterable, TYPE_CHECKING, List, Optional

from .selectable import Selectable

if TYPE_CHECKING:
    from omen2 import ObjBase, Omen, Table
    from typing import Type

T = TypeVar("T")


# noinspection PyProtectedMember,PyDefaultArgument
class Relation(Selectable[T]):
    # pylint: disable=protected-access, dangerous-default-value

    table_type: "Type[Table[T]]" = None

    @property
    def row_type(self):
        return self.table_type.row_type

    def __init__(self, _from: "ObjBase", _init=None, *, where=None, cascade):
        self.cascade = cascade

        self._from = _from
        self._where = where
        self.__table: Optional["Table"] = None
        self.__saved: List["ObjBase"] = []
        if _init:
            for ent in _init:
                if isinstance(ent, dict):
                    self.add(T(ent))
                else:
                    self.add(ent)

    def is_bound(self):
        return self._from._is_bound

    @property
    def table(self):
        if not self.__table:
            mgr: "Omen" = self._from._table.manager
            self.__table: "Table" = mgr.get_table_by_name(self.table_type.table_name)
            self.table_type = type(self.__table)
        return self.__table

    def add(self, obj: "ObjBase"):
        """Add object to relation.

        If relation is unbound, the object is stored in ram until the relation object is committed.

        TODO: could allow adding by **kws primary key (like m2m adds)
        """
        if not self.is_bound():
            self.__saved.append(obj)
        else:
            self._link_obj(obj)
            self.table.add(obj)

    def remove(self, obj: "ObjBase"):
        """Remove object from relation.

        TODO: could allow removing by **kws primary key (like m2m removes)
        """
        self.table.remove(obj)

    def __len__(self):
        """Inefficient count.


        TODO: Could be more efficient, and call self.table.count(**where)
        """
        return sum(1 for _ in self.select())

    def select(self, _where={}, **kws) -> Iterable[T]:
        """Works like select on the related table, except it is filtered by those matching my relation.

        Example using lambda, can be useful if 'driverid' is autogenerated:

            self.drivers = gen_objs.drivers_relation(
                self, where={"id": lambda: self.driverid}, cascade=False
            )
        """
        where = {**_where, **kws, **self._where}
        for k, v in where.items():
            if isinstance(v, Callable):
                where[k] = v()
        if self.is_bound():
            for obj in self.table.select(**where):
                if obj not in self.__saved:
                    yield obj
        for obj in self.__saved:
            if obj._matches(where):
                yield obj

    def _link_obj(self, obj):
        obj._table = self.table
        with obj:
            for k, v in self._where.items():
                if isinstance(v, Callable):
                    v = v()
                setattr(obj, k, v)

    def commit(self, manager=None):
        """Bind/add any items were added while I was unbound.

        # TODO: relation-with-blocks that track changes, just like their parents.
        """
        if not manager:
            manager = self.table.manager
        for item in self.__saved:
            if not item._is_bound:
                item._bind(manager=manager)
            self._link_obj(item)
        self.__saved.clear()

    def __iter__(self):
        return self.select()
