# SPDX-FileCopyrightText: Â© Atakama, Inc <support@atakama.com>
# SPDX-License-Identifier: LGPL-3.0-or-later

"""Omen2: One to many relationship helper."""

from typing import TypeVar, Callable, Generator, TYPE_CHECKING, List, Optional

from .selectable import Selectable

if TYPE_CHECKING:
    from omen2 import ObjBase, Omen, Table
    from typing import Type

T = TypeVar("T", bound="ObjBase")


# noinspection PyProtectedMember,PyDefaultArgument
class Relation(Selectable[T]):
    """Omen2: One to many relationship helper."""

    # pylint: disable=protected-access, dangerous-default-value

    table_type: "Type[Table[T]]" = None

    @property
    def row_type(self):
        """Get row type"""
        return self.table_type.row_type

    def __init__(self, _from: "ObjBase", _init=None, *, where=None, cascade):
        self.cascade = cascade

        self._from = _from
        self._where = where
        self.__table: Optional["Table"] = None
        self.__saved: List["ObjBase"] = []
        if _init:
            for ent in _init:
                self.add(ent)

    def is_bound(self):
        """Is this relation bound to the db."""
        return self._from._is_bound

    @property
    def table(self):
        """Get bound table."""
        if not self.is_bound():
            return None
        if not self.__table:
            mgr: "Omen" = self._from._table.manager
            self.__table: "Table" = mgr.get_table_by_name(self.table_type.table_name)
            self.table_type = type(self.__table)
        return self.__table

    def add(self, obj: "ObjBase"):
        """Add object to relation.

        If relation is unbound, the object is stored in ram until the relation object is committed.

        TODO: could allow adding by **kws primary key (like m2m adds)
        """
        if not self.is_bound():
            try:
                self._link_obj(obj)
            except AttributeError:
                # allowed if you're adding an object that will be committed later
                # needed for test_readme to pass: car with pre-constructed unbound doors
                pass
            self.__saved.append(obj)
        else:
            self._link_obj(obj)
            self.table.add(obj)

    def remove(self, obj: T):
        """Remove object from relation.

        TODO: could allow removing by **kws primary key (like m2m removes)
        """
        self.table.remove(obj)

    def select(self, _where={}, **kws) -> Generator[T, None, None]:
        """Works like select on the related table, except it is filtered by those matching my relation.

        Example using lambda, can be useful if 'driverid' is autogenerated:

            self.drivers = gen_objs.drivers_relation(
                self, where={"id": lambda: self.driverid}, cascade=False
            )
        """
        where = {**_where, **kws, **self._where}
        for k, v in where.items():
            if isinstance(v, Callable):
                where[k] = v()
        if self.is_bound():
            for obj in self.table.select(**where):
                if obj not in self.__saved:
                    yield obj
        for obj in self.__saved:
            if obj._matches(where):
                yield obj

    def _link_obj(self, obj):
        if self.table:
            obj._table = self.table
        with obj:
            for k, v in self._where.items():
                if isinstance(v, Callable):
                    v = v()
                setattr(obj, k, v)

    def commit(self, manager=None):
        """Bind/add any items were added while I was unbound.

        TODO: relation-with-blocks that track changes, just like their parents.
        """
        if not manager:
            manager = self.table.manager
        for item in self.__saved:
            if not item._is_bound:
                item._bind(manager=manager)
            self._link_obj(item)
            item._commit()
        self.__saved.clear()
